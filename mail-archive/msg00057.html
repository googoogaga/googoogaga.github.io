<!-- MHonArc v2.5.2 -->
<!--X-Subject: Re: Threads -->
<!--X-From-R13: Yrvgu Bynlsbeq <xrvgu.cynlsbeqNcbobk.pbz> -->
<!--X-Date: Sat, 11 May 2002 19:56:53 &#45;0400 (EDT) -->
<!--X-Message-Id: 187101473437.20020512005532@pobox.com -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 4A7DD480&#45;6516&#45;11D6&#45;BDC0&#45;00306563529C@io.com -->
<!--X-Reference: uo8lmaqcsa2.fsf@djundjun.ai.mit.edu -->
<!--X-Head-End-->
<!doctype html public "-//W3C//DTD HTML//EN">
<html>
<head>
<title>Re: Threads</title>
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg00056.html">Date Prev</a>][<a href="msg00058.html">Date Next</a>][<a href="msg00056.html">Thread Prev</a>][<a href="msg00058.html">Thread Next</a>][<a href="index.html#00057">Date Index</a>][<a href="threads.html#00057">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Threads</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: <A HREF="mailto:owner-googoogaga@DOMAIN.HIDDEN">owner-googoogaga@xxxxxxxxxx</A>, Jonathan Bachrach &lt;<A HREF="mailto:jrb@DOMAIN.HIDDEN">jrb@xxxxxxxxxx</A>&gt;</li>
<li><em>Subject</em>: Re: Threads</li>
<li><em>From</em>: Keith Playford &lt;<A HREF="mailto:keith.playford@DOMAIN.HIDDEN">keith.playford@xxxxxxxxx</A>&gt;</li>
<li><em>Date</em>: Sun, 12 May 2002 00:55:32 +0100</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
IIRC, LispWorks for Windows among others uses a hack whereby each Lisp
thread is associated with a genuine native thread, but constrained
such that only one of them can be actively executing in Lisp at any
given time. Under that scheme, a blocking native call isn't a problem
as long as the calling thread is flagged as not being in Lisp before
the native library function is entered.

Scheduling between Lisp-mode threads eligible to run could be achieved
most simply by making them &quot;cooperatively preemptive&quot; in some way;
e.g. by taking the hit of adding lightweight reschedule-point checks
at function entry points and in loops (triggered either by counting or
by a timer on a utility thread). Because this brings with it the
sledgehammer synchronization primitive that is &quot;without-preemption&quot;,
you could probably get Goo running stably using this approach in
pretty short order.

If your threads are lightweight (i.e. a single native thread exists
that manages a number of lightweight thread objects, perhaps more
typical in VM-based implementations), the choices are limited. You
pretty much have to farm out native calls to other native threads
dedicated to that chore in order to keep moving. Once the generic
infrastructure's in place though, writing native methods in that
environment isn't much more difficult than it is anywhere else.

-- Keith


</pre>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<ul><li><strong>References</strong>:
<ul>
<li><strong><a name="00056" href="msg00056.html">Re: Threads</a></strong>
<ul><li><em>From:</em> Jonathan Bachrach</li></ul></li>
</ul></li></ul>
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg00056.html">Re: Threads</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg00058.html">RE: Threads</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg00056.html">Re: Threads</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg00058.html">RE: Threads</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="index.html#00057"><strong>Date</strong></a></li>
<li><a href="threads.html#00057"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
